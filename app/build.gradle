apply plugin: 'com.android.application'
//apply from: "../node_modules/react-native/react.gradle"
apply plugin: 'com.neenbedankt.android-apt'

android {
    compileSdkVersion 23
    buildToolsVersion '24.0.1'

    defaultConfig {
        applicationId rootProject.app.applicationId
        minSdkVersion 16
        targetSdkVersion 23
        versionCode 1
        versionName rootProject.app.versionName
//        manifestPlaceholders = [ activityLabel:"defaultName"]
        project.archivesBaseName = "wefan";
        vectorDrawables.useSupportLibrary = true

        ndk {
            abiFilters "armeabi-v7a", "x86"
        }
        packagingOptions {
            exclude "lib/arm64-v8a/libgnustl_shared.so"
        }
    }
    signingConfigs {
        release {
            storeFile file('../buildsystem/wefan.keystore')
            storePassword 'wefan@baidu.com'
            keyAlias 'wefan'
            keyPassword 'wefan@baidu.com'
        }
    }

    buildTypes {
        debug {
            def conf = rootProject.debug
            buildConfigField("String", "API_URL", "\"debug\"")
            applicationIdSuffix '.debug'
//            resValue("string", "app_name", "\"${conf.appName}\"")
        }
        release {
            def conf = rootProject.release
            buildConfigField("String", "API_URL", "\"release\"")
//            resValue("string", "app_name", "\"${conf.appName}\"")
            minifyEnabled true
            shrinkResources true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        zmyz.initWith(buildTypes.debug)
        zmyz {
            def conf = rootProject.zmy
//            resValue("string", "app_name", "\"${conf.appName}\"")
            buildConfigField("String", "API_URL", "\"zmy\"")
        }
    }
//    productFlavors {
//        /*配置一*/
//
//        //渠道一的配置
//        channelname1 {
//            //把manifest中的“CHANNEL”变量名（key）的变量值（value）替换成xxx1
//            //这里也可以把“"xxx1"” 换成name=> [CHANNEL:name]  这个的意思就是把value换成 channelname1
//            //由于网上的乱七八糟的粘贴复制 所有网上的那些根本没说清楚，这里的CHANNEL必须要再manifest中有且对应 具体我写在下面代码块
//            manifestPlaceholders = [CHANNEL: "xxx1"]
//        }
//        //渠道二的配置
//        channelname2 {
//            manifestPlaceholders = [CHANNEL: "xxx2"]
//        }
//
//        /*配置二*/
//        channelname1 {}
//        channelname2 {}
//        //执行all方法，循环把 channelname*赋值给manifest中的变量
//        all { flavor ->
//            flavor.manifestPlaceholders = [CHANNEL: name]
//        }
//    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    lintOptions {
        abortOnError false
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])


//    compile project(':RNGL')

    debugCompile project(path: ':library', configuration: 'debug')
    releaseCompile project(path: ':library', configuration: 'release')
    zmyzCompile project(path: ':library', configuration: 'zmyz')

    compile 'com.android.support:design:23.4.0'
    compile 'com.facebook.react:react-native:+'
    compile 'com.android.support:support-v4:23.4.0'
    compile 'com.android.support:support-vector-drawable:23.4.0'
    testCompile 'junit:junit:4.12'

    compile project(':annotation')
    apt project(":complier")

//    compile project(':weex_sdk')

    compile 'com.bettervectordrawable:lib:0.8+'


}

task hello {
    doLast {
        println 'Hello zmy!'
        println "zmy $projectDir"
        println "zmy $rootDir"
    }
}

tasks.getByName("assemble") {
    it.doLast {
        println "$project.name: After assemble"
        rootProject.renameApks()

        println "$projectDir"
        println "$rootDir"
    }
}

android.applicationVariants.all { variant ->
    variant.outputs.each { output ->
        def file = output.outputFile
        output.outputFile = new File(file.parent, file.name.replace(".apk", "-" + android.defaultConfig.versionName + ".apk"))
    }
}

/*
  因为我的项目只提供最终的release编译出来的Jar包给其他人，所以不需要编译debug版的东西
  当Project创建完所有任务的有向图后，我通过afterEvaluate函数设置一个回调Closure。在这个回调
  Closure里，我disable了所有Debug的Task
*/
//project.afterEvaluate{
//    disableDebugBuild()
//}

afterEvaluate {
    android.applicationVariants.each { variant ->
        println("zzz   ${variant.name.capitalize()}")
//        def dx = tasks.findByName("${variant.name.capitalize()}")
//        def hello = "hello${variant.name.capitalize()}"
//        task(hello) << {
//            println "hello"
//        }
//        tasks.findByName(hello).dependsOn dx.taskDependencies.getDependencies(dx)
//        dx.dependsOn tasks.findByName(hello)
    }
}

class TimingsListener implements TaskExecutionListener, BuildListener {
    private Clock clock
    private timings = []

    @Override
    void beforeExecute(Task task) {
        clock = new org.gradle.util.Clock()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = clock.timeInMs
        timings.add([ms, task.path])
        task.project.logger.warn "${task.path} took ${ms}ms"
    }

    @Override
    void buildFinished(BuildResult result) {
        println "Task timings:"
        for (timing in timings) {
            if (timing[0] >= 50) {
                printf "%7sms  %s\n", timing
            }
        }


    }

    @Override
    void buildStarted(Gradle gradle) {}

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}
}

gradle.addListener new TimingsListener()
