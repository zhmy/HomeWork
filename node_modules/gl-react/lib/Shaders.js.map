{"version":3,"sources":["../src/Shaders.js"],"names":["invariant","require","defer","INLINE_NAME","_uid","names","shaders","shadersCompileResponses","shadersCompileResults","shadersReferenceCounters","surfaceInlines","previousSurfaceInlines","implDefer","implementation","promise","add","existingId","findShaderId","shader","id","name","then","impl","result","remove","getShadersToRemove","Object","keys","filter","map","parseInt","scheduled","gcNow","clearTimeout","forEach","scheduleGC","noDebounce","length","setTimeout","sameShader","a","b","frag","logError","console","error","Shaders","_onSurfaceWillMount","surfaceId","_onSurfaceWillUnmount","_beforeSurfaceBuild","_resolve","idOrObject","compileHandler","catch","get","inlines","push","_afterSurfaceBuild","create","obj","onAllCompile","compileErrors","compileResults","Promise","all","key","freeze","getCompilationResult","getCompilationPromise","list","exists","setImplementation","resolve","module","exports"],"mappings":"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","file":"Shaders.js","sourcesContent":["const invariant = require(\"invariant\");\nconst defer = require(\"promise-defer\");\n\nconst INLINE_NAME = \"<inline>\";\n\nlet _uid = 1;\nconst names = {}; // keep names\nconst shaders = {}; // keep shader objects\nconst shadersCompileResponses = {}; // keep promise of compile responses\nconst shadersCompileResults = {}; // keep only the successful result\nconst shadersReferenceCounters = {}; // reference count the shaders created with Shaders.create()/used inline so we don't delete them if one of 2 dups is still used\n\nconst surfaceInlines = {};\nconst previousSurfaceInlines = {};\n\nlet implDefer = defer();\nconst implementation = implDefer.promise;\n\nconst add = shader => {\n  const existingId = findShaderId(shaders, shader);\n  const id = existingId || _uid ++;\n  let promise;\n  if (!existingId) {\n    names[id] = shader.name;\n    shaders[id] = shader;\n    shadersReferenceCounters[id] = 0;\n    shadersCompileResponses[id] = promise =\n    implementation\n      .then(impl => impl.add(id, shader))\n      .then(result => shadersCompileResults[id] = result);\n  }\n  else {\n    promise = shadersCompileResponses[id];\n  }\n  return { id, promise };\n};\n\nconst remove = id => {\n  delete shaders[id];\n  delete names[id];\n  delete shadersReferenceCounters[id];\n  delete shadersCompileResponses[id];\n  implementation.then(impl => impl.remove(id));\n};\n\nconst getShadersToRemove = () =>\n  Object.keys(shadersReferenceCounters)\n  .filter(id => shadersReferenceCounters[id] <= 0)\n  .map(id => parseInt(id, 10));\n\nlet scheduled;\nconst gcNow = () => {\n  clearTimeout(scheduled);\n  getShadersToRemove().forEach(remove);\n};\nconst scheduleGC = () => {\n  // debounce the shader deletion to let a last chance to a future dup shader to appear\n  // the idea is also to postpone this operation when the app is not so busy\n  const noDebounce = getShadersToRemove().length > 20;\n  if (!noDebounce) clearTimeout(scheduled);\n  scheduled = setTimeout(gcNow, 500);\n};\n\nconst sameShader = (a, b) => a.frag === b.frag;\n\nconst findShaderId = (shaders, shader) => {\n  for (let id in shaders) {\n    if (sameShader(shaders[id], shader)) {\n      return parseInt(id, 10);\n    }\n  }\n  return null;\n};\n\nconst logError = shader => error =>\n  console.error( //eslint-disable-line no-console\n    \"Shader '\" + shader.name + \"' failed to compile:\\n\" + error\n  );\n\nconst Shaders = {\n\n  _onSurfaceWillMount (surfaceId) {\n    surfaceInlines[surfaceId] = [];\n  },\n\n  _onSurfaceWillUnmount (surfaceId) {\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    delete surfaceInlines[surfaceId];\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  _beforeSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId] = surfaceInlines[surfaceId];\n    surfaceInlines[surfaceId] = [];\n  },\n\n  // Resolve the shader field of GL.Node.\n  // it can be an id (created with Shaders.create) or an inline object.\n  _resolve (idOrObject, surfaceId, compileHandler) {\n    if (typeof idOrObject === \"number\") return idOrObject;\n    const { id, promise } = add({ name: INLINE_NAME, ...idOrObject });\n    if (compileHandler) {\n      promise.then(\n        result => compileHandler(null, result),\n        error => compileHandler(error));\n    }\n    else {\n      promise.catch(logError(Shaders.get(id)));\n    }\n    const inlines = surfaceInlines[surfaceId];\n    inlines.push(id);\n    return id;\n  },\n\n  _afterSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]++);\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  //~~~ Exposed methods ~~~ //\n\n  // Create shaders statically\n  create (obj, onAllCompile) {\n    invariant(typeof obj === \"object\", \"config must be an object\");\n    const result = {};\n    const compileErrors = {}, compileResults = {};\n    Promise.all(Object.keys(obj).map(key => {\n      const shader = obj[key];\n      invariant(typeof shader === \"object\" && typeof shader.frag === \"string\",\n      \"invalid shader given to Shaders.create(). A valid shader is a { frag: String }\");\n      const {id, promise} = add({ name: key, ...shader });\n      result[key] = id;\n      shadersReferenceCounters[id] ++;\n      return promise.then(\n        result => compileResults[key] = result,\n        error => compileErrors[key] = error\n      );\n    }))\n    .then(() => {\n      if (onAllCompile) {\n        onAllCompile(\n          Object.keys(compileErrors).length ? compileErrors : null,\n          compileResults);\n      }\n      else {\n        Object.keys(compileErrors).forEach(key =>\n          logError(Shaders.get(result[key]))(compileErrors[key]));\n      }\n    });\n    return result;\n  },\n\n  // Get the shader object by id.\n  get (id) {\n    return Object.freeze(shaders[id]);\n  },\n\n  // Synchronously retrieve the successful compilation response.\n  // returns or ShaderResult object or null if there were a failure or not ready\n  getCompilationResult (id) {\n    return shadersCompileResults[id] || null;\n  },\n\n  // Get the promise of the compilation state. Allows you to wait for compilation\n  // and also map on errors.\n  // Returns null only if you never have created this shader.\n  getCompilationPromise (id) {\n    return shadersCompileResponses[id] || null;\n  },\n\n  // List all shader ids that exists at the moment.\n  list () {\n    return Object.keys(shaders);\n  },\n\n  // Check if a shader exists\n  exists (id) {\n    return id in shaders;\n  },\n\n  gcNow,\n\n  setImplementation: impl => {\n    invariant(implDefer, \"Shaders.setImplementation can be called only once\");\n    implDefer.resolve(impl);\n    implDefer = null;\n  },\n\n  implementation\n};\n\nmodule.exports = Object.freeze(Shaders);\n"]}